// SOLVES PROJECT EULER 189 TRI-COLORING A TRIANGULAR GRID
// https://projecteuler.net/problem=189

#include <algorithm>
#include <iostream>
#include <numeric>
#include <stack>
#include <unordered_map>
#include <vector>
using namespace std;

using i64 = int64_t;
using u64 = uint64_t;
using i32 = int32_t;
using u32 = uint32_t;
using i128 = __int128_t;
using u128 = __uint128_t;
using pr = pair<u32, u32>;

// DATA TYPE FOR SOLUTION
// using  Tp = i128;
using Tp = i64;

// 128 BIT INTEGER I/O METHODS
int popcnt128(u128 n) {
    u64 low = static_cast<u64>(n);
    u64 high = static_cast<u64>(n >> 64);
    return __builtin_popcountll(low) + __builtin_popcountll(high);
}
int ctz128(u128 n) {
    if (n == 0)  return 128; // Special case for zero
    u64 low = n;
    if (low != 0)  return __builtin_ctzll(low);
    u64 high = n >> 64;
    return 64 + __builtin_ctzll(high);
}
string toString(i128 value) {
    string output;
    while (output.empty() || value > 0) {
        output = (char)(value % 10 + '0') + output;
        value /= 10;
    }
    return output;
}
istream &operator>>(istream &stream, i128 &v) {
    string s;
    stream >> s;
    bool neg = false;
    if (s[0] == '-') {
        s.erase(0, 1);
        neg = true;
    }
    int len = s.length();
    v = 0;
    for (int32_t i = 0; i < len; ++i) v = v * 10 + s[i] - '0';
    if (neg) v = -v;
    return stream;
}
ostream &operator<<(ostream &stream, i128 v) {
    if (v == 0)
        stream << "0";
    else {
        if (v < 0) {
            stream << "-";
            v = -v;
        }
        stream << toString(v);
    }
    return stream;
}

Tp pow(Tp a, u64 i) {
    Tp r = a, res = 1;
    while (i) {
        if (i & 1) res = res * r;
        r = r * r;
        i >>= 1;
    }
    return res;
}

// REQUIRE HASH FOR AN UNORDERED MAP TO MEMOIZE GRAPH/POLYNOMIAL PAIRS
struct hash128 {
    size_t operator()(const u128& val) const {
        const u64 hi = static_cast<u64>(val >> 64);
        const u64 lo = static_cast<u64>(val);
        return std::hash<u64>()(hi) ^ std::hash<u64>()(lo);
    }
};

inline void hash_combine(size_t& seed, const u128& v) {
    seed ^= hash128()(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}
struct VectorHash {
    size_t operator()(const vector<u128>& vec) const {
        size_t seed = 0;
        for (const auto& i : vec)  hash_combine(seed, i);
        return seed;
    }
};
unordered_map<vector<u128>, Tp, VectorHash> memo;

vector<Tp> clique;

class Graph {
   public:
    vector<u128> g;

    // CONSTRUCTORS
    Graph(){};
    Graph(const vector<u128> &v) { g = v; }

    Graph contractEdge(const pr &edge) {
        Graph G(*this);
        const auto [u, v] = edge;
        G.g[u] |= G.g[v];
        for (auto &e : G.g) e |= (e >> v & 1) << u;
        G.g[u] &= ~(u128(1) << u);
        for (auto &e : G.g)
            e = (e & ~(~u128(0) << v)) | (e & (~u128(0) << (v + 1))) >> 1;
        G.g.erase(G.g.begin() + v);
        return G;
    }

    bool findBridge(pr &edge) {
        const u32 n = g.size();
        u32 best = 0, timer = 0;
        u128 visited = u128(0);
        vector<u32> tin(n, 0), low(n, 0);
        edge = {0, 0};

        for (u32 i = 0; i < n; ++i)
            if (!(visited >> i & 1))
                bridgeDFS(tin, low, visited, timer, best, edge, i);
        return (edge != pr({0, 0})) ? true : false;
    }

    bool isComplete() {
        const int n = (int)g.size() - 1;
        for (auto e : g)
            if (popcnt128(e) != n) return false;
        return true;
    }

    bool isLoop() {  // ASSUMES G IS CONNECTED AND NOT CHORDAL
        if (g.size() < 4) return false;
        for (const auto& e : g)
            if (popcnt128(e) != 2) return false;
        return true;
    }

    Graph deleteEdge(const pr &edge) {
        const auto [u, v] = edge;
        Graph K(*this);
        K.g[u] &= ~(u128(1) << v);
        K.g[v] &= ~(u128(1) << u);
        return K;
    }

    Graph addEdge(const pr &edge) {
        const auto [u, v] = edge;
        Graph K(*this);
        K.g[u] |= (u128(1) << v);
        K.g[v] |= (u128(1) << u);
        return K;
    }

    pr chooseEdge() {
        const u32 n = g.size();
        pr edge = {0, 0};
        u32 best = 0;

        for (u32 u = 0; u < n; ++u) {
            auto e = g[u];
            const u32 p = popcnt128(e) / 3;
            // e REPS NBRS OF u WITH INDEX > u
            e &= ~u128(0) << u;

            while (e) {
                const u32 w = ctz128(e);
                e &= ~(u128(1) << w);

                if (best == 0 || p + popcnt128(g[w]) < best) {
                    best = p + popcnt128(g[w]);
                    edge = {u, w};
                }
            }
        }
        return edge;
    }

    pr newEdge() {
        const u32 n = g.size();
        pr edge = {0, 0};
        u32 best = 0;

        for (u32 u = 0; u < n; ++u) {
            auto e = g[u];
            const u32 p = popcnt128(e);
            // e REPS NON NBRS OF u WITH INDEX > u
            e = ~(e ^ (~u128(0) << n)) & (~u128(0) << (u + 1));

            while (e) {
                const u32 w = ctz128(e);
                e &= ~(u128(1) << w);

                if (best == 0 || p + popcnt128(g[w]) > best) {
                    best = p + popcnt128(g[w]);
                    edge = {u, w};
                }
            }
        }
        return edge;
    }

    int countEdges2x() {
        int ret = 0;
        for (auto &e : g) ret += popcnt128(e);
        return ret;
    }

    double density() {
        return double(countEdges2x()) / double(g.size() * (g.size() - 1));
    }

    Graph extractNodes(const vector<u32> &nodes) {
        const size_t n = nodes.size();
        Graph G(*this);
        for (size_t i = 0; i < n; ++i) G.g[i] = G.g[nodes[i]];
        G.g.resize(n);

        for (auto &e : G.g) {
            for (size_t j = 0; j < n; ++j)
                e = (e & ~(u128(1) << j)) | (e >> nodes[j] & 1) << j;
            e &= (u128(1) << n) - 1;
        }
        return G;
    }

    // FIND ORDERING USED TO TEST FOR CHORDAL GRAPH
    vector<u32> maximumCardinalitySearch() {
        const i32 n = g.size();
        vector<u32> ordering(n);
        vector<i32> lp(2 * n + 1), idx(n, 0);

        iota(lp.begin(), lp.end(), 0);
        vector<i32> rp(lp);

        auto Insert = [&](i32 i, i32 j) {
            rp[lp[j]] = i;
            lp[i] = lp[j];
            lp[j] = i;
            rp[i] = j;
        };
        auto Erase = [&](i32 i) {
            rp[lp[i]] = rp[i];
            lp[rp[i]] = lp[i];
        };

        for (i32 i = 0; i < n; ++i) Insert(i, n);

        for (i32 i = 0, d = n + 1; i < n; ++i, ++d) {
            while (lp[d] == d) --d;
            const i32 v = lp[d];
            auto e = g[v];
            idx[v] = -1;
            Erase(v);

            while (e) {
                const u32 w = ctz128(e);
                e &= ~(u128(1) << w);
                if (idx[w] >= 0) {
                    Erase(w);
                    Insert(w, n + (++idx[w]));
                }
            }
            ordering[i] = v;
        }
        return ordering;
    }

    Tp checkIfChordal(Tp K) {
        const vector<u32> ordering = maximumCardinalitySearch();

        u128 visited = 0;
        vector<u32> tally(g.size(), 0);

        for (const u32 &u : ordering) {
            auto neighbors = g[u] & visited;
            u32 counter = 0;

            while (neighbors) {
                const u32 v = ctz128(neighbors);
                neighbors &= ~(u128(1) << v);
                if ((g[v] & neighbors) != neighbors) return 0;
                ++counter;
            }
            visited |= u128(1) << u;
            ++tally[counter];
        }

        // G IS CHORDAL
        Tp chromPoly = 1;
        for (i32 i = 0; i < (i32)g.size(); ++i)
            if (tally[i]) chromPoly *= pow(Tp(K - i), tally[i]);
        return chromPoly;
    }

    // FIND CONNECTED COMPONENTS OF G
    vector<vector<u32>> components() {
        const u32 n = g.size();
        u128 visited = u128(0);
        vector<vector<u32>> comps;

        for (u32 i = 0; i < n; ++i) {
            if (visited >> i & 1) continue;
            stack<u32> stk;
            stk.push(i);
            visited |= u128(1) << i;
            vector<u32> component;

            while (stk.size()) {
                const u32 u = stk.top();
                auto e = g[u];
                stk.pop();
                component.push_back(u);

                while (e) {
                    const u32 w = ctz128(e);
                    e &= ~(u128(1) << w);
                    if (!(visited >> w & 1)) {
                        visited |= u128(1) << w;
                        stk.push(w);
                    }
                }
            }
            sort(component.begin(), component.end());
            comps.push_back(component);
        }
        return comps;
    }

    Tp chromaticPolynomial(Tp K) {
        // FIND CONNECTED COMPONENTS OF G
        vector<vector<u32>> comps = components();

        // PROCESS EACH CONNECTED COMPONENT SEPARATELY
        if (comps.size() > 1) {
            Tp cp = 1;
            for (auto &cmp : comps) {
                if (cmp.size() == 0)
                    ;
                else if (cmp.size() == 1)
                    cp *= K;
                else if (cmp.size() == 2)
                    cp *= K * K - K;
                else
                    cp *= extractNodes(cmp).chromaticPolyConnected(K);
            }
            return cp;
        }
        return chromaticPolyConnected(K);
    }

   private:
    void bridgeDFS(vector<u32> &tin, vector<u32> &low, u128 &visited, u32 &timer,
                   u32 &best, pr &edge, u32 u, i32 p = -1) {
        auto e = g[u];
        const u32 pcu = popcnt128(e);
        bool parentSkipped = false;
        tin[u] = low[u] = timer++;
        visited |= (u128(1) << u);

        while (e) {
            const i32 w = ctz128(e);
            e &= ~(u128(1) << w);

            if (w == p && !parentSkipped) {
                parentSkipped = true;
                continue;
            }
            if (visited >> w & 1) {
                low[u] = min(low[u], tin[w]);
            } else {
                bridgeDFS(tin, low, visited, timer, best, edge, w, u);
                low[u] = min(low[u], low[w]);
                if (low[w] > tin[u] &&
                    pcu + popcnt128(g[w]) > best) {
                    best = pcu + popcnt128(g[w]);
                    edge = {u, w};
                }
            }
        }
    }

    Tp chromaticPolyConnected(Tp K, bool checkBridges = true) {
        // G IS ASSUMED CONNECTED.  CONNECTIVITY IS MAINTAINED.
        const i32 n = g.size();
        if (n == 0) return 1;
        if (n == 1) return K;
        if (n == 2) return K * K - K;
        if (n == 3) {
            if (isComplete())
                return clique[3];
            else
                return K * (K * K - K - K + 1);
        }

        if (memo.find(g) != memo.end()) return memo[g];

        // CHECK FOR COMPLETE GRAPH
        if (isComplete()) return memo[g] = clique[n];

        // CHECK FOR BRIDGES
        if (checkBridges) {
            pr edge;
            if (findBridge(edge))
                return memo[g] = contractEdge(edge).chromaticPolyConnected(K) *
                                 (K - 1);
        }

        // CHECK IF G IS CHORDAL
        Tp chordalVal = checkIfChordal(K);
        if (chordalVal) return memo[g] = chordalVal;

        // CHECK IF LOOP
        if (isLoop()) {
            Tp d = K - 1;
            Tp chromPoly = pow(d, n);
            if (g.size() & 1)
                chromPoly -= d;
            else
                chromPoly += d;
            return chromPoly;
        }

        // NO JOY.  PERFORM DELETION/CONTRACTION.
        if (density() <= .6) {
            // LOW DENSITY
            pr edge = chooseEdge();
            return memo[g] = deleteEdge(edge).chromaticPolyConnected(K) -
                             contractEdge(edge).chromaticPolyConnected(K);
        }

        // IF HIGH DENSITY
        pr edge = newEdge();
        Graph H = addEdge(edge);
        return memo[g] = H.chromaticPolyConnected(K, false) +
                         H.contractEdge(edge).chromaticPolyConnected(K);
    }
};

Graph getG(int rows) {
    // REQUIRES THE N NODES TO BE LABELED  0 through ( N - 1 )
    size_t n = rows * rows;
    vector<u128> g(n, 0);
    Graph G(g);

    for (size_t N = 0; N < n; ++N) {
        for (size_t j = N * N;; ++j) {
            size_t i = j + 1;
            if (i >= (N + 1) * (N + 1) || i >= n) break;
            G = G.addEdge(make_pair(i, j));
            G = G.addEdge(make_pair(j, i));
        }
    }

    for (size_t N = 0; N < n; ++N) {
        for (size_t j = N * N;; j += 2) {
            size_t i = j + ((N + 1) * 2);
            if (j >= (N + 1) * (N + 1) || i >= n) break;
            G = G.addEdge(make_pair(i, j));
            G = G.addEdge(make_pair(j, i));
        }
    }
    return G;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    memo.reserve(1000);
    memo.max_load_factor(0.7);

    u32 rows = 8;  // NUMBER OF ROWS OF TRIANGLES
    Tp K = 3;      // NUMBER OF COLORS

    Graph G = getG(rows);

    // PRECOMPUTE VALUES FOR CLIQUES
    int sz = rows * rows;
    clique.resize(sz + 1);
    Tp val = 1;
    for (i32 i = 0; i < sz; ++i) {
        val *= Tp(K - i);
        clique[i + 1] = val;
    }

    auto ans = G.chromaticPolynomial(K);
    cout << ans << '\n';

    return 0;
}
